<!DOCTYPE html>
<html lang="ja" class="h-full bg-gray-50">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEAT.js XOR Solver - Minimal White UI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* === IMPROVED EVOLUTION PARAMETERS STYLES START === */
        .param-label {
            @apply block text-sm font-medium text-gray-600 mb-1;
        }
        .param-input {
            @apply block w-full px-3 py-2.5 
                   bg-white border border-gray-300 rounded-lg 
                   text-sm text-gray-800 
                   focus:outline-none focus:border-indigo-500 focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-30 
                   transition-all duration-150 ease-in-out;
        }
        .param-input::placeholder {
            @apply text-gray-400;
        }

        /* Hide number input spinners for a cleaner UI */
        .param-input[type="number"]::-webkit-inner-spin-button,
        .param-input[type="number"]::-webkit-outer-spin-button {
          -webkit-appearance: none;
          margin: 0;
        }
        .param-input[type="number"] {
          -moz-appearance: textfield; /* Firefox */
        }
        /* === IMPROVED EVOLUTION PARAMETERS STYLES END === */
        
        /* General styles from original, kept for other parts of UI */
        canvas { @apply border border-gray-300 rounded-md shadow-sm bg-white; }
        
        .output-log::-webkit-scrollbar { width: 8px; }
        .output-log::-webkit-scrollbar-track { background: #e5e7eb; border-radius: 10px; }
        .output-log::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 10px; }
        .output-log::-webkit-scrollbar-thumb:hover { background: #6b7280; }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
        }
        .main-scroll-container {
            height: 100%;
            overflow-y: auto;
            padding: 1rem; 
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center bg-gray-100 text-gray-800">

    <div class="main-scroll-container w-full">
        <div class="w-full max-w-7xl mx-auto bg-white shadow-xl rounded-lg p-6 space-y-6">
            <header class="text-center">
                <h1 class="text-3xl font-bold text-indigo-700">🧠 NEAT.js XOR Solver</h1>
                <p class="text-gray-600 mt-1">Evolving neural networks to solve the XOR problem with configurable parameters.</p>
            </header>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- === EVOLUTION PARAMETERS SECTION WITH IMPROVED STYLES === -->
                <div class="lg:col-span-1 space-y-5 p-6 bg-gray-50 rounded-xl border border-gray-200">
                    <div>
                        <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b border-gray-200 pb-2">Evolution Parameters</h2>
                        <div class="space-y-4"> {/* Increased spacing between parameter items */}
                            <div>
                                <label for="populationSize" class="param-label">Population Size</label>
                                <input type="number" id="populationSize" value="150" min="10" class="param-input">
                            </div>
                            <div>
                                <label for="maxGenerations" class="param-label">Max Generations</label>
                                <input type="number" id="maxGenerations" value="100" min="1" class="param-input">
                            </div>
                            <div>
                                <label for="elitism" class="param-label">Elitism (Top N)</label>
                                <input type="number" id="elitism" value="1" min="0" class="param-input">
                            </div>
                            <div>
                                <label for="addNodeRate" class="param-label">Add Node Rate (0-1)</label>
                                <input type="number" step="0.001" id="addNodeRate" value="0.03" min="0" max="1" class="param-input">
                            </div>
                            <div>
                                <label for="addConnectionRate" class="param-label">Add Connection Rate (0-1)</label>
                                <input type="number" step="0.001" id="addConnectionRate" value="0.05" min="0" max="1" class="param-input">
                            </div>
                            <div>
                                <label for="weightMutationRate" class="param-label">Weight Mutation Rate (0-1)</label>
                                <input type="number" step="0.01" id="weightMutationRate" value="0.8" min="0" max="1" class="param-input">
                            </div>
                            <div>
                                <label for="weightPerturbation" class="param-label">Weight Perturbation (+/-)</label>
                                <input type="number" step="0.01" id="weightPerturbation" value="0.1" min="0" class="param-input">
                            </div>
                        </div>
                    </div>

                    <button id="solveXORButton" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2.5 px-4 rounded-lg shadow-md transition duration-150 ease-in-out focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-50 disabled:opacity-50 disabled:cursor-not-allowed">
                        Solve XOR Problem
                    </button>

                    <div class="w-full bg-gray-200 rounded-full h-2.5"> {/* Slimmer progress bar */}
                        <div id="progressBar" class="bg-indigo-500 h-2.5 rounded-full transition-all duration-300 ease-out" style="width: 0%"></div>
                    </div>
                </div>
                <!-- === END OF EVOLUTION PARAMETERS SECTION === -->


                <div class="lg:col-span-2 space-y-6">
                    <div class="grid grid-cols-1 xl:grid-cols-5 gap-4">
                        <div class="xl:col-span-3 p-4 bg-gray-50 rounded-lg shadow-inner">
                            <h3 class="text-lg font-semibold text-gray-700 mb-2">Evolution Log</h3>
                            <div id="outputLog" class="output-log h-48 bg-gray-800 text-gray-200 p-3 rounded-md text-xs font-mono overflow-y-auto whitespace-pre-wrap">
                                <!-- Log messages will appear here -->
                            </div>
                        </div>
                        <div class="xl:col-span-2 p-4 bg-gray-50 rounded-lg shadow-inner">
                            <h3 class="text-lg font-semibold text-gray-700 mb-3">Statistics</h3>
                            <div class="space-y-1.5 text-sm">
                                <div class="flex justify-between"><span>Generation:</span> <span id="statGeneration" class="font-semibold text-indigo-600">-</span></div>
                                <div class="flex justify-between"><span>Best Fitness:</span> <span id="statBestFitness" class="font-semibold text-indigo-600">-</span></div>
                                <div class="flex justify-between"><span>Avg. Nodes:</span> <span id="statAvgNodes" class="font-semibold text-indigo-600">-</span></div>
                                <div class="flex justify-between"><span>Avg. Connections:</span> <span id="statAvgConnections" class="font-semibold text-indigo-600">-</span></div>
                                <div class="mt-2 pt-2 border-t border-gray-300">
                                    <h4 class="font-medium text-gray-600 mb-1">XOR Test Results:</h4>
                                    <div id="xorTestResultsContainer" class="text-xs space-y-0.5">
                                        <!-- XOR test results will be populated here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                            <h3 class="text-lg font-semibold text-gray-700 mb-2 text-center">XOR Output Visualization</h3>
                            <canvas id="xorOutputCanvas" width="280" height="280" class="mx-auto"></canvas>
                        </div>
                        <div class="p-4 bg-gray-50 rounded-lg shadow-inner">
                            <h3 class="text-lg font-semibold text-gray-700 mb-2 text-center">Best Network Structure</h3>
                            <canvas id="networkCanvas" width="380" height="280" class="mx-auto"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="release/neat.js"></script> {/* Assuming neat.js is in release/ folder */}
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const populationSizeInput = document.getElementById('populationSize');
            const maxGenerationsInput = document.getElementById('maxGenerations');
            const elitismInput = document.getElementById('elitism');
            const addNodeRateInput = document.getElementById('addNodeRate');
            const addConnectionRateInput = document.getElementById('addConnectionRate');
            const weightMutationRateInput = document.getElementById('weightMutationRate');
            const weightPerturbationInput = document.getElementById('weightPerturbation');
            
            const solveButton = document.getElementById('solveXORButton');
            const progressBar = document.getElementById('progressBar');
            const outputLogDiv = document.getElementById('outputLog');
            
            const statGeneration = document.getElementById('statGeneration');
            const statBestFitness = document.getElementById('statBestFitness');
            const statAvgNodes = document.getElementById('statAvgNodes');
            const statAvgConnections = document.getElementById('statAvgConnections');
            
            const xorTestResultsDiv = document.getElementById('xorTestResultsContainer');
            const xorOutputCanvas = document.getElementById('xorOutputCanvas');
            const networkCanvas = document.getElementById('networkCanvas');

            let neatInstance;
            let bestGenomeStorage = null;

            function logMessage(message) {
                const timestamp = new Date().toLocaleTimeString();
                outputLogDiv.innerHTML += `[${timestamp}] ${message}\n`;
                outputLogDiv.scrollTop = outputLogDiv.scrollHeight;
            }

            function updateProgressBar(percentage) {
                progressBar.style.width = percentage + '%';
            }

            function resetUIState() {
                outputLogDiv.innerHTML = '';
                statGeneration.textContent = '-';
                statBestFitness.textContent = '-';
                statAvgNodes.textContent = '-';
                statAvgConnections.textContent = '-';
                xorTestResultsDiv.innerHTML = '<p class="text-gray-400">Run evolution to see results.</p>';
                
                const xorCtx = xorOutputCanvas.getContext('2d');
                xorCtx.clearRect(0, 0, xorOutputCanvas.width, xorOutputCanvas.height);
                xorCtx.fillStyle = '#f9fafb'; // bg-gray-50
                xorCtx.fillRect(0,0, xorOutputCanvas.width, xorOutputCanvas.height);


                const networkCtx = networkCanvas.getContext('2d');
                networkCtx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
                networkCtx.fillStyle = '#f9fafb';
                networkCtx.fillRect(0,0, networkCanvas.width, networkCanvas.height);


                updateProgressBar(0);
                bestGenomeStorage = null;
            }
            
            function displayStatistics(result, currentNeatInstance) {
                statGeneration.textContent = result.generation;
                statBestFitness.textContent = result.bestFitness.toFixed(5);
                const popStats = currentNeatInstance.getStats(result.population);
                statAvgNodes.textContent = popStats.averageNodes.toFixed(2);
                statAvgConnections.textContent = popStats.averageConnections.toFixed(2);
            }

            function runXORTests(genome, currentNeatInstance) {
                if (!genome) {
                    logMessage("No genome available for testing.");
                    xorTestResultsDiv.innerHTML = '<p class="text-red-500">Error: No genome to test.</p>';
                    return;
                }
                const network = currentNeatInstance.createNetwork(genome);
                const testCases = [
                    { input: [0, 0], expected: 0 }, { input: [0, 1], expected: 1 },
                    { input: [1, 0], expected: 1 }, { input: [1, 1], expected: 0 }
                ];

                let resultsHTML = '';
                logMessage("--- XOR Test Results ---");
                testCases.forEach(tc => {
                    const output = network.execute(tc.input);
                    const actual = output[0];
                    const correct = Math.abs(actual - tc.expected) < 0.5;
                    const resultText = `XOR(${tc.input.join(',')}) = ${actual.toFixed(3)} (exp: ${tc.expected}) ${correct ? '✅' : '❌'}`;
                    logMessage(resultText);
                    resultsHTML += `
                        <div class="flex justify-between items-center ${correct ? 'text-green-600' : 'text-red-600'}">
                            <span>(${tc.input.join(',')}) → ${actual.toFixed(3)}</span>
                            <span class="font-bold">${correct ? 'PASS' : 'FAIL'}</span>
                        </div>`;
                });
                xorTestResultsDiv.innerHTML = resultsHTML;
            }

            function visualizeXOROutput(genome, currentNeatInstance) {
                if (!genome) return;
                const ctx = xorOutputCanvas.getContext('2d');
                const network = currentNeatInstance.createNetwork(genome);
                const resolution = 100; 
                const cellWidth = xorOutputCanvas.width / resolution;
                const cellHeight = xorOutputCanvas.height / resolution;

                ctx.clearRect(0, 0, xorOutputCanvas.width, xorOutputCanvas.height);
                for (let i = 0; i < resolution; i++) {
                    for (let j = 0; j < resolution; j++) {
                        const x = i / (resolution - 1);
                        const y = j / (resolution - 1);
                        const outputVal = network.execute([x, y])[0];
                        const clampedVal = Math.max(0, Math.min(1, outputVal));
                        
                        const hue = (1 - clampedVal) * 240; 
                        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                        ctx.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);
                    }
                }
                logMessage("XOR output visualization updated.");
            }

            function drawNetworkDiagram(genome, currentNeatInstance) {
                if (!genome) return;
                const ctx = networkCanvas.getContext('2d');
                ctx.clearRect(0, 0, networkCanvas.width, networkCanvas.height);
                
                const nodeRadius = 8;
                const paddingX = 40;
                const paddingY = 30;
                const layerSpacingX = (networkCanvas.width - 2 * paddingX) / 2; 

                const { nodes, connections } = genome;
                const nodePositions = new Map();

                const inputNodes = nodes.filter(n => n.type === 'input').sort((a,b) => a.id - b.id);
                const outputNodes = nodes.filter(n => n.type === 'output').sort((a,b) => a.id - b.id);
                const hiddenNodes = nodes.filter(n => n.type === 'hidden').sort((a,b) => a.id - b.id);

                function calculateYPos(nodeList, index, totalHeight) {
                    const spacing = (totalHeight - nodeList.length * nodeRadius * 2) / (nodeList.length + 1);
                    return paddingY + (index + 1) * spacing + index * nodeRadius * 2 + nodeRadius;
                }

                const canvasHeight = networkCanvas.height - 2 * paddingY;

                inputNodes.forEach((node, i) => nodePositions.set(node.id, { x: paddingX, y: calculateYPos(inputNodes, i, canvasHeight) }));
                outputNodes.forEach((node, i) => nodePositions.set(node.id, { x: paddingX + 2 * layerSpacingX, y: calculateYPos(outputNodes, i, canvasHeight) }));
                hiddenNodes.forEach((node, i) => nodePositions.set(node.id, { x: paddingX + layerSpacingX, y: calculateYPos(hiddenNodes, i, canvasHeight) }));

                connections.forEach(conn => {
                    if (!conn.enabled) return;
                    const fromPos = nodePositions.get(conn.from);
                    const toPos = nodePositions.get(conn.to);
                    if (fromPos && toPos) {
                        ctx.beginPath();
                        ctx.moveTo(fromPos.x, fromPos.y);
                        ctx.lineTo(toPos.x, toPos.y);
                        const weightAbs = Math.abs(conn.weight);
                        const alpha = Math.min(1, weightAbs / 2); 
                        ctx.strokeStyle = conn.weight > 0 ? `rgba(74, 222, 128, ${alpha})` : `rgba(248, 113, 113, ${alpha})`; 
                        ctx.lineWidth = Math.max(0.5, Math.min(4, weightAbs));
                        ctx.stroke();
                    }
                });

                nodePositions.forEach((pos, id) => {
                    const node = nodes.find(n => n.id === id);
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, nodeRadius, 0, 2 * Math.PI);
                    if (node.type === 'input') ctx.fillStyle = '#60a5fa'; 
                    else if (node.type === 'output') ctx.fillStyle = '#34d399'; 
                    else ctx.fillStyle = '#facc15'; 
                    ctx.fill();
                    ctx.strokeStyle = '#4b5563'; 
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
                logMessage("Best network structure drawn.");
            }

            solveButton.addEventListener('click', async () => {
                solveButton.disabled = true;
                resetUIState();
                logMessage("Initializing NEAT evolution...");

                neatInstance = new NEAT.NEAT({ seed: Math.floor(Math.random() * 10000) }); 

                const evolutionParams = {
                    ...NEAT.DEFAULT_EVOLUTION_CONFIG,
                    populationSize: parseInt(populationSizeInput.value),
                    maxGenerations: parseInt(maxGenerationsInput.value),
                    elitism: parseInt(elitismInput.value),
                    addNodeMutationRate: parseFloat(addNodeRateInput.value),
                    addConnectionMutationRate: parseFloat(addConnectionRateInput.value),
                    weightMutationRate: parseFloat(weightMutationRateInput.value),
                    weightPerturbation: parseFloat(weightPerturbationInput.value),
                };

                logMessage(`Starting evolution: Pop=${evolutionParams.populationSize}, Gens=${evolutionParams.maxGenerations}`);
                updateProgressBar(5); 

                const fitnessFunction = (genome) => {
                    const network = neatInstance.createNetwork(genome);
                    let fitness = 4.0; 
                    const testCases = [
                        { input: [0, 0], expected: 0 }, { input: [0, 1], expected: 1 },
                        { input: [1, 0], expected: 1 }, { input: [1, 1], expected: 0 }
                    ];
                    for (const tc of testCases) {
                        const output = network.execute(tc.input);
                        fitness -= Math.pow(output[0] - tc.expected, 2);
                    }
                    return { fitness: Math.max(0, fitness) }; 
                };
                
                try {
                    const result = await neatInstance.run(2, 1, fitnessFunction, evolutionParams);
                    
                    bestGenomeStorage = result.bestGenome;
                    updateProgressBar(100);
                    logMessage(`Evolution finished! Generations: ${result.generation}, Best Fitness: ${result.bestFitness.toFixed(5)}`);

                    displayStatistics(result, neatInstance);
                    runXORTests(bestGenomeStorage, neatInstance);
                    visualizeXOROutput(bestGenomeStorage, neatInstance);
                    drawNetworkDiagram(bestGenomeStorage, neatInstance);

                } catch (error) {
                    logMessage(`Evolution Error: ${error.message}`);
                    console.error(error);
                    updateProgressBar(0);
                } finally {
                    solveButton.disabled = false;
                }
            });
            
            resetUIState();
            logMessage('Welcome! Configure parameters and click "Solve XOR Problem" to begin.');
        });
    </script>
</body>
</html>