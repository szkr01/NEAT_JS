!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.NEAT=e():t.NEAT=e()}(this,()=>(()=>{"use strict";var t,e,n={d:(t,e)=>{for(var o in e)n.o(e,o)&&!n.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},o={};n.r(o),n.d(o,{ActivationFunction:()=>i,ActivationFunctionFactory:()=>s,ActivationType:()=>t,DAG:()=>a,DEFAULT_EVOLUTION_CONFIG:()=>S,DEFAULT_MUTATION_CONFIG:()=>I,EvolutionEngine:()=>x,EvolutionEngineFactory:()=>M,Genome:()=>d,Mutator:()=>R,MutatorFactory:()=>C,NEAT:()=>T,Network:()=>m,NetworkBuilder:()=>g,NetworkGenerator:()=>p,NetworkGeneratorFactory:()=>_,NodeType:()=>e,RandomGeneratorFactory:()=>b,RouletteWheelSelection:()=>v,SimpleRandomGenerator:()=>f,StandardRandomGenerator:()=>w,TournamentSelection:()=>y,neat:()=>O}),function(t){t.None="none",t.Sigmoid="sigmoid",t.ReLU="relu",t.Tanh="tanh"}(t||(t={})),function(t){t.Input="input",t.Hidden="hidden",t.Output="output"}(e||(e={}));class i{constructor(t){this.activationType=t}activate(e){switch(this.activationType){case t.None:return e;case t.Sigmoid:return 1/(1+Math.exp(-4.9*e));case t.ReLU:return.5*(e+Math.abs(e));case t.Tanh:return Math.tanh(e);default:return e}}getType(){return this.activationType}}class s{static getFunction(t){return this.instances.has(t)||this.instances.set(t,new i(t)),this.instances.get(t)}static createFunction(t){return new i(t)}}s.instances=new Map;class r{constructor(){this._incoming=0,this._depth=0,this._outConnections=[]}get incoming(){return this._incoming}get depth(){return this._depth}get outConnections(){return this._outConnections}addOutConnection(t){this._outConnections.push(t)}removeOutConnection(t){const e=this._outConnections.indexOf(t);return-1!==e&&(this._outConnections.splice(e,1),!0)}incrementIncoming(){this._incoming++}decrementIncoming(){this._incoming--}setDepth(t){this._depth=t}}class a{constructor(){this._nodes=[]}get nodes(){return this._nodes}createNode(){return this._nodes.push(new r),this._nodes.length-1}createConnection(t,e){return!(!this.isValid(t)||!this.isValid(e)||t===e||this.isAncestor(e,t)||this.isParent(t,e)||(this._nodes[t].addOutConnection(e),this._nodes[e].incrementIncoming(),0))}removeConnection(t,e){this.isValid(t)&&this.isValid(e)&&this._nodes[t].removeOutConnection(e)&&this._nodes[e].decrementIncoming()}isValid(t){return t>=0&&t<this._nodes.length}isParent(t,e){return!!this.isValid(t)&&this._nodes[t].outConnections.includes(e)}isAncestor(t,e){return!!this.isValid(t)&&(!!this.isParent(t,e)||this._nodes[t].outConnections.some(t=>this.isAncestor(t,e)))}computeDepth(){const t=this._nodes.length,e=[],n=this._nodes.map(t=>t.incoming);for(let o=0;o<t;o++)0===n[o]&&(this._nodes[o].setDepth(0),e.push(o));for(;e.length>0;){const t=e.pop(),o=this._nodes[t];for(const t of o.outConnections){n[t]--;const i=this._nodes[t],s=Math.max(i.depth,o.depth+1);i.setDepth(s),0===n[t]&&e.push(t)}}}getTopologicalOrder(){const t=[];for(let e=0;e<this._nodes.length;e++)t.push(e);return t.sort((t,e)=>this._nodes[t].depth-this._nodes[e].depth),t}}class h{constructor(t,e,n,o=0,i=0){this.id=t,this.type=e,this.activation=n,this._bias=o,this._depth=i}get bias(){return this._bias}get depth(){return this._depth}setBias(t){return new h(this.id,this.type,this.activation,t,this._depth)}setDepth(t){return new h(this.id,this.type,this.activation,this._bias,t)}}class c{constructor(t,e,n,o=!0){this.from=t,this.to=e,this._weight=n,this.enabled=o}get weight(){return this._weight}setWeight(t){return new c(this.from,this.to,t,this.enabled)}setEnabled(t){return new c(this.from,this.to,this._weight,t)}}class d{constructor(n,o){this._nodes=[],this._connections=[],this._dag=new a,this._info={inputs:n,outputs:o,hidden:0};for(let o=0;o<n;o++)this.createNode(t.None,e.Input);for(let n=0;n<o;n++)this.createNode(t.Tanh,e.Output)}get info(){return this._info}get nodes(){return this._nodes}get connections(){return this._connections}get dag(){return this._dag}createNode(t,n=e.Hidden){const o=this._dag.createNode(),i=new h(o,n,t);return this._nodes.push(i),n===e.Hidden&&(this._info={...this._info,hidden:this._info.hidden+1}),o}createConnection(t,e,n){if(this._dag.createConnection(t,e)){const o=new c(t,e,n);return this._connections.push(o),!0}return!1}splitConnection(n){if(n<0||n>=this._connections.length)return!1;const o=this._connections[n];if(!o.enabled)return!1;const i=this.createNode(t.ReLU,e.Hidden);return this._connections[n]=o.setEnabled(!1),this.createConnection(o.from,i,o.weight),this.createConnection(i,o.to,1),!0}removeConnection(t){if(t<0||t>=this._connections.length)return;const e=this._connections[t];this._dag.removeConnection(e.from,e.to),this._connections.splice(t,1)}isInputNode(t){return t<this._info.inputs}isOutputNode(t){return t>=this._info.inputs&&t<this._info.inputs+this._info.outputs}isHiddenNode(t){return t>=this._info.inputs+this._info.outputs}computeDepth(){this._dag.computeDepth();for(let t=0;t<this._nodes.length;t++){const e=this._dag.nodes[t];this._nodes[t]=this._nodes[t].setDepth(e.depth)}const t=Math.max(...this._nodes.map(t=>t.depth)),e=Math.max(t,1);for(let t=this._info.inputs;t<this._info.inputs+this._info.outputs;t++)this._nodes[t]=this._nodes[t].setDepth(e)}getTopologicalOrder(){this.computeDepth();const t=[];for(let e=0;e<this._nodes.length;e++)t.push(e);return t.sort((t,e)=>this._nodes[t].depth-this._nodes[e].depth),t}updateNodeBias(t,e){t>=0&&t<this._nodes.length&&(this._nodes[t]=this._nodes[t].setBias(e))}updateConnectionWeight(t,e){t>=0&&t<this._connections.length&&(this._connections[t]=this._connections[t].setWeight(e))}clone(){const t=new d(this._info.inputs,this._info.outputs);for(const n of this._nodes)n.type===e.Hidden&&t.createNode(n.activation,e.Hidden);for(const e of this._connections)e.enabled&&t.createConnection(e.from,e.to,e.weight);for(let e=0;e<this._nodes.length;e++)e<t._nodes.length&&(t._nodes[e]=t._nodes[e].setBias(this._nodes[e].bias));return t}}class u{constructor(t,e,n,o){this.activation=t,this.bias=e,this.depth=n,this.connectionCount=o,this._sum=0}setValue(t){this._sum=t}getValue(){return this._sum}getActivatedValue(){return this.activation.activate(this._sum+this.bias)}reset(){this._sum=0}}class l{constructor(t,e){this.to=t,this.weight=e,this._value=0}getValue(){return this._value}setValue(t){this._value=t*this.weight}}class m{constructor(t,e,n,o){this._nodes=[],this._connections=[],this._outputs=[],this._info=t,this._nodes=[...e],this._connections=[...n],this._outputs=new Array(t.outputs).fill(0),this._maxDepth=o}get info(){return this._info}get maxDepth(){return this._maxDepth}execute(t){if(t.length!==this._info.inputs)throw new Error(`Input size mismatch: expected ${this._info.inputs}, got ${t.length}`);this.reset();for(let e=0;e<this._info.inputs;e++)this._nodes[e].setValue(t[e]);let e=0;for(let t=0;t<this._nodes.length;t++){const n=this._nodes[t],o=n.getActivatedValue();for(let t=0;t<n.connectionCount;t++){const t=this._connections[e++];t.setValue(o),this._nodes[t.to].setValue(this._nodes[t.to].getValue()+t.getValue())}}const n=this._info.inputs+this._info.hidden;for(let t=0;t<this._info.outputs;t++)this._outputs[t]=this._nodes[n+t].getActivatedValue();return this._outputs}getOutputs(){return this._outputs}reset(){for(const t of this._nodes)t.reset()}static builder(){return new g}}class g{constructor(){this._nodes=[],this._connections=[],this._maxDepth=0}setInfo(t){return this._info=t,this}addNode(t,e,n,o){const i=new u(t,e,n,o);return this._nodes.push(i),this._maxDepth=Math.max(this._maxDepth,n),this}addConnection(t,e){const n=new l(t,e);return this._connections.push(n),this}build(){if(!this._info)throw new Error("Network info must be set before building");return new m(this._info,this._nodes,this._connections,this._maxDepth)}}class p{constructor(){this.indexToOrder=[]}generate(t){const e=t.getTopologicalOrder();this.indexToOrder.length=t.info.inputs+t.info.outputs+t.info.hidden;for(let t=0;t<e.length;t++)this.indexToOrder[e[t]]=t;const n=m.builder().setInfo(t.info);for(const o of e){const e=t.nodes[o],i=s.getFunction(e.activation),r=t.connections.filter(t=>t.from===o&&t.enabled);n.addNode(i,e.bias,e.depth,r.length)}for(const o of e){const e=t.connections.filter(t=>t.from===o&&t.enabled);for(const t of e){const e=this.indexToOrder[t.to];n.addConnection(e,t.weight)}}return n.build()}}class _{static getInstance(){return this.instance||(this.instance=new p),this.instance}static createGenerator(){return new p}}_.instance=null;class f{constructor(t=Date.now()){this._seed=t}random(){return this._seed=(1664525*this._seed+1013904223)%Math.pow(2,32),this._seed/Math.pow(2,32)}randomInt(t){return Math.floor(this.random()*t)}randomRange(t,e){return t+this.random()*(e-t)}probability(t){return this.random()<t}choice(t){return t[this.randomInt(t.length)]}seed(t){this._seed=t}}class w{random(){return Math.random()}randomInt(t){return Math.floor(this.random()*t)}randomRange(t,e){return t+this.random()*(e-t)}probability(t){return this.random()<t}choice(t){return t[this.randomInt(t.length)]}seed(t){console.warn("StandardRandomGenerator does not support seeding. Use SimpleRandomGenerator for reproducible results.")}}class b{static getInstance(){return this.instance}static setInstance(t){this.instance=t}static createSimple(t){return new f(t)}static createStandard(){return new w}}b.instance=new w;class R{constructor(t){this.random=t??b.getInstance()}mutate(t,e){const n=t.clone();for(let t=0;t<e.mutationCount;t++)this.random.probability(.25)&&(this.random.probability(.5)?this.mutateBiases(n,e):this.mutateWeights(n,e));return this.random.probability(e.addNodeRate)&&e.maxHiddenNodes>n.info.hidden&&this.addNode(n,e),this.random.probability(e.addConnectionRate)&&this.addConnection(n,e),n}mutateBiases(t,e){if(0===t.nodes.length)return;const n=this.random.randomInt(t.nodes.length),o=t.nodes[n];let i;i=this.random.probability(e.newValueProbability)?this.random.randomRange(-e.weightRange,e.weightRange):this.random.probability(.25)?o.bias+this.random.randomRange(-e.weightRange,e.weightRange):o.bias+e.weightSmallRange*this.random.randomRange(-e.weightRange,e.weightRange),this.updateNodeBias(t,n,i)}mutateWeights(t,e){if(0===t.connections.length)return;const n=this.random.randomInt(t.connections.length),o=t.connections[n];let i;i=this.random.probability(e.newValueProbability)?this.random.randomRange(-e.weightRange,e.weightRange):this.random.probability(.75)?o.weight+e.weightSmallRange*this.random.randomRange(-e.weightRange,e.weightRange):o.weight+this.random.randomRange(-e.weightRange,e.weightRange),this.updateConnectionWeight(t,n,i)}addNode(t,e){if(0===t.connections.length)return;const n=t.connections.map((t,e)=>({connection:t,index:e})).filter(t=>t.connection.enabled);if(0===n.length)return;const o=this.random.choice(n);t.splitConnection(o.index)}addConnection(t,e){const n=t.info.inputs+t.info.hidden;let o=this.random.randomInt(n);o>=t.info.inputs&&o<t.info.inputs+t.info.outputs&&(o+=t.info.outputs);const i=t.info.hidden+t.info.outputs,s=this.random.randomInt(i)+t.info.inputs,r=this.random.randomRange(-e.weightRange,e.weightRange);t.createConnection(o,s,r)}updateNodeBias(t,e,n){t.updateNodeBias(e,n)}updateConnectionWeight(t,e,n){t.updateConnectionWeight(e,n)}}class C{static createMutator(t){return new R(t)}static createWithSeed(t){const e=b.createSimple(t);return new R(e)}}class y{constructor(t=3){this.tournamentSize=t}select(t,e,n){const o=[];for(let i=0;i<n;i++){let n=Math.floor(Math.random()*t.length),i=e[n];for(let o=1;o<this.tournamentSize;o++){const o=Math.floor(Math.random()*t.length),s=e[o];s>i&&(n=o,i=s)}o.push(t[n])}return o}}class v{select(t,e,n){const o=[],i=e.reduce((t,e)=>t+Math.max(0,e),0);if(0===i){for(let e=0;e<n;e++){const e=Math.floor(Math.random()*t.length);o.push(t[e])}return o}for(let s=0;s<n;s++){const n=Math.random()*i;let s=0;for(let i=0;i<t.length;i++)if(s+=Math.max(0,e[i]),n<=s){o.push(t[i]);break}}return o}}class N{constructor(t,e,n,o,i){this.bestGenome=t,this.bestFitness=e,this.generation=n,this.population=o,this.fitnessHistory=i}}class x{constructor(t=new y,e){this.selectionStrategy=t,this.mutator=e}evolve(t,e,n,o){let i=[...t];const s=[];let r=i[0],a=-1/0;for(let t=0;t<n.maxGenerations;t++){const h=i.map(t=>e(t).fitness);for(let t=0;t<i.length;t++)h[t]>a&&(a=h[t],r=i[t]);if(s.push(a),void 0!==n.fitnessThreshold&&a>=n.fitnessThreshold)return new N(r,a,t+1,i,s);const c=[],d=Array.from({length:i.length},(t,e)=>e).sort((t,e)=>h[e]-h[t]);for(let t=0;t<n.eliteCount&&t<i.length;t++)c.push(i[d[t]]);const u=n.populationSize-n.eliteCount,l=this.selectionStrategy.select(i,h,u);for(const t of l){const e=this.mutator.mutate(t,o);c.push(e)}if(i=c,this.shouldTerminateEarly(s,t))break}return new N(r,a,s.length,i,s)}shouldTerminateEarly(t,e){if(e<10)return!1;const n=t.slice(-10);return Math.max(...n)-Math.min(...n)<1e-6}}class M{static createWithTournamentSelection(t,e=3){return new x(new y(e),t)}static createWithRouletteSelection(t){return new x(new v,t)}}const I={weightMutationRate:.8,biasMutationRate:.7,addNodeRate:.03,addConnectionRate:.05,weightRange:2,weightSmallRange:.1,newValueProbability:.1,maxHiddenNodes:100,mutationCount:3},S={populationSize:150,eliteCount:5,selectionPressure:2,maxGenerations:100};class T{constructor(t){t?.useSimpleRandom||void 0!==t?.seed?(this.random=b.createSimple(t?.seed),b.setInstance(this.random)):this.random=b.getInstance(),this.networkGenerator=_.getInstance(),this.mutator=C.createMutator(this.random),this.evolutionEngine=M.createWithTournamentSelection(this.mutator)}createGenome(t,e){return new d(t,e)}createNetwork(t){return this.networkGenerator.generate(t)}mutateGenome(t,e=I){return this.mutator.mutate(t,e)}createInitialPopulation(t,e,n,o=I){const i=[];for(let s=0;s<n;s++){let n=this.createGenome(t,e);const s=this.random.randomInt(t*e)+1;for(let i=0;i<s;i++){const i=this.random.randomInt(t),s=this.random.randomInt(e)+t,r=this.random.randomRange(-o.weightRange,o.weightRange);n.createConnection(i,s,r)}n=this.mutateGenome(n,{...o,addNodeRate:.1*o.addNodeRate,addConnectionRate:.5*o.addConnectionRate}),i.push(n)}return i}evolve(t,e,n=S,o=I){return this.evolutionEngine.evolve(t,e,n,o)}run(t,e,n,o=S,i=I){const s=this.createInitialPopulation(t,e,o.populationSize,i);return this.evolve(s,n,o,i)}setSeed(t){this.random.seed(t)}getStats(t){const e=t.map(t=>t.info.inputs+t.info.outputs+t.info.hidden),n=t.map(t=>t.connections.length);return{averageNodes:e.reduce((t,e)=>t+e,0)/e.length,averageConnections:n.reduce((t,e)=>t+e,0)/n.length,maxNodes:Math.max(...e),maxConnections:Math.max(...n),speciesCount:1}}}const O=new T;return o})());